
# Project 3
## A study in simple design
###### Joe

For me, this project served as an experiment. I have followed a lot of video game analysis on what makes a game good. Often, the idea brought up was that of simple design. One or Two core mechanics that interact with a lot of different ones. I wanted to test that in an endless runner environment, as it allows for a long playtime to test the amount of fun and unique dynamics that could come up. That was the original plan. 

I then started thinking about what my core mechanic will be. Casting fire at a certain spot to kill enemies. I had a narrative behind it, one which I didn't implement in this prototype for simplicity and time management. The idea was that the player character used to be a great warrior one that would defend people from calamities. The gods were enraged by the actions of this hero, as they halted the Gods' design for human death. They placed curses on this warrior, making them lose their strength and unable to ever pick up a weapon again. One go however, which I admit was inspired by Prometheus gifted the hero with the ability to use magic. The other gods, entertained by the hero's desire to still keep fighting, allowed him to keep the magic with a condition. He cannot make projectiles, he can't throw any attack at an enemy. So our hero now possesses magic which he can only cast a certain distance away from himself. 

My main ideas were to either have the player character in a fixed position on the screen, endlessly running towards enemies coming to attack where he could make fire spawn on top of them and rain down on them killing them. The other idea was the have the player be able to move but cast the fire a set distance away from himself thus requiring precise control of the character's position and the direction they are looking at. 

Using Phaser 3, a library which I haven't used before I set out to create these two version to see which one would be the more fun one. As both are based in simple design, which was my objective for this project.

Using Phaser, gave me both advantages and disadvantages, the main advantages were that it animates sprites easily and handles collision really well. 
The disadvantages were, first I am unfamiliar with the specific properties in Phaser so I spent more time learning than working. The biggest example of that was figuring out groups. running my initial test I had one zombie run on the screen towards the player the player could jump over them or smite them down with fire rain. Upon dying or reaching the end of the screen I would play the zombie's death animation, reset its position and that's it. When it came to adding more zombies, I thought I would simply create an array and put them in. Except calling a game object from an array in Phaser did not work as intended, I was unable to access a certain element from the array as a game object. It took a lot of time and research to learn about groups and implement them in my code. 

Another problem I ran into while programming this, is the update function. It is difficult, in libraries with one initial function and one function which runs 60 times a second (normal refresh rate), to handle a condition which results in something running once. So i often found myself jumping through hoops trying to set variables to make the function run only once or wait for an animation to finish then run. 

There are a few examples of that, which are still present in my program, one of which are the zombie death. It would've been a lot easier had I just chosen to instantly remove the zombie from the game upon overlap with fire. I, however, wanted to run a death animation first. To handle a death animation running, and running only once, then once completed remove a zombie from the game. I had to deal with the potential of the player dying on the zombie's hitbox, or the zombie executing other commands while it's running its death animation. The way I handled that was I created an offset which applies to the zombie's hit box on the death animation, sending their hitbox away from where their sprite is displayed. That causes some weird clunkiness visually when the zombie dies, and sometimes the sprite will just fall off the screen ignoring collisions all together.  

Another example is the player death, since the function is called upon interaction with a zombie, if two zombies interact with the player back to back it resets the death animation (which waits to restart the game till the animation ends) that is very similar to the zombie death, if the the animation is reset then the player sprite just stands there (since the first frame of the death animation is the player standing) and the game restarts.

One final example of the clunkiness caused by my lack of knowledge in this library, is the player jumping. I couldn't figure out a way to make the animation while the player is in the air remain on the couple of frames where it looks like they are floating or falling. So if the player double jumps it looks like he jumped then kicked off something mid air to jump again. However this problem also causes a really unique interaction. In the first level if the player jumps and casts a fire behind them then it plays the animation for the player turning around and casting fire while midair, which looks really cool.

Overall, I am happy with these 2 levels as prototypes, I enjoyed simple design a lot. I find the second level more challenging but it has more potential to be flushed out. The first level already displays some of the qualities of unique interactions arising from few mechanics, such as the midair cast I mentioned earlier. From a design perspective, I find that these have met their objective, which was prototyping an idea. from a programing perspective, I definitely can clean them off more, but they serve their purpose as prototypes, and I learned using a new library in the process.

I also added a second library last minute, Particles.js, but that was to meet a requirement as well as to see how that library works as well as how the interaction between 2 canvases works. I didn't put a lot of thought into it, it was an aesthetic choice as well as experimenting with a library. 
